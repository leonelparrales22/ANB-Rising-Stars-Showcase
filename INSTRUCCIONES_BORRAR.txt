Entrega No. 1 
Implementaci√≥n de una API REST escalable con orquestaci√≥n de 
tareas as√≠ncronas para el procesamiento de archivos 
Objetivos 
Dise√±ar e implementar una aplicaci√≥n web escalable, orientada a la gesti√≥n de archivos y al 
procesamiento as√≠ncrono de tareas, que garantice un desempe√±o eficiente, escalable, y que soporte 
de manera confiable la concurrencia de m√∫ltiples usuarios. 
‚Ä¢ Desarrollar una API RESTful escalable y segura para la gesti√≥n de usuarios y recursos, con contratos 
documentados en OpenAPI, autenticaci√≥n y autorizaci√≥n basada en tokens. 
‚Ä¢ Implementar un sistema de procesamiento as√≠ncrono que permita la ejecuci√≥n de tareas en segundo 
plano de manera eficiente y confiable, incorporando colas de mensajes, mecanismos de reintento 
con backoff, y manejo de fallos mediante Dead Letter Queues. 
‚Ä¢ Administrar el almacenamiento de archivos garantizando seguridad, eficiencia y disponibilidad. 
‚Ä¢ Orquestar el despliegue de la aplicaci√≥n en un entorno basado en contenedores que asegure su 
portabilidad, resiliencia y escalabilidad. 
‚Ä¢ Documentar la arquitectura del sistema, incluyendo los diagramas de niveles (C4), las decisiones de 
dise√±o, los contratos de la API, los diagramas de despliegue. 
Tiempo de dedicaci√≥n 
La presente entrega, correspondiente a la fase desarrollo, est√° programada para un periodo de dos 
semanas. Durante este tiempo, cada estudiante deber√° destinar las horas asignadas en la 
planificaci√≥n semanal. Se recuerda la importancia de conformar equipos de trabajo de acuerdo con las 
directrices establecidas en el curso, como condici√≥n clave para el √©xito de la actividad. 
Componentes de la evaluaci√≥n 
La distribuci√≥n de la calificaci√≥n de la entrega est√° distribuida de la siguiente manera: 
1. Dise√±o e implementaci√≥n de la API RESTful (40%) 
‚Ä¢ Implementaci√≥n de endpoints: conforme a lo establecido en la secci√≥n especificaci√≥n del API 
REST. 
‚Ä¢ Gesti√≥n de solicitudes y respuestas: aplicaci√≥n rigurosa de c√≥digos de estado HTTP y definici√≥n 
estructurada de las respuestas. 
‚Ä¢ Validaci√≥n y manejo de errores: establecimiento de reglas de validaci√≥n y generaci√≥n de 
reportes de error consistentes y alineados con las mejores pr√°cticas. 
2. Autenticaci√≥n y seguridad (5%) 
‚Ä¢ Implementaci√≥n de JWT: incorporaci√≥n de tokens para los procesos de autenticaci√≥n y 
autorizaci√≥n de usuarios. 
‚Ä¢ Protecci√≥n de endpoints: aseguramiento de rutas cr√≠ticas mediante la verificaci√≥n de permisos y 
controles de acceso. 
3. Procesamiento as√≠ncrono de tareas (20%) 
‚Ä¢ Configuraci√≥n del sistema de gesti√≥n de tareas as√≠ncronas: integraci√≥n efectiva con el broker de 
mensajer√≠a seleccionado. 
‚Ä¢ Implementaci√≥n y monitoreo de tareas as√≠ncronas, garantizando su ejecuci√≥n eficiente y 
trazabilidad. 
‚Ä¢ Consideraci√≥n de Apache Kafka como alternativa v√°lida: su arquitectura distribuida y 
orientada a eventos permite gestionar grandes vol√∫menes de mensajes con alta disponibilidad, 
tolerancia a fallos y escalabilidad horizontal, lo que la convierte en una opci√≥n robusta frente a 
sistemas tradicionales de message brokering. 
‚Ä¢ Manejo de errores y reintentos: definici√≥n de estrategias para la atenci√≥n de fallos en la ejecuci√≥n 
de tareas as√≠ncronas. 
4. Gesti√≥n y almacenamiento de archivos (5%) 
‚Ä¢ Almacenamiento seguro: gesti√≥n eficiente y confiable de los archivos cargados por los usuarios, 
garantizando integridad y confidencialidad. 
‚Ä¢ Conversi√≥n y procesamiento: implementaci√≥n de la l√≥gica de transformaci√≥n de archivos 
conforme a los requisitos funcionales y t√©cnicos definidos. 
‚Ä¢ Acceso y descarga: provisi√≥n de mecanismos seguros y controlados para la recuperaci√≥n de 
archivos procesados. 
‚Ä¢ Se recomienda la implementaci√≥n de una capa de abstracci√≥n para el almacenamiento de 
archivos. Adoptar este patr√≥n de dise√±o, definiendo una interfaz clara. Este enfoque desacopla 
por completo la l√≥gica de negocio de los detalles de la infraestructura de almacenamiento. En la 
pr√°ctica, esto garantiza que la futura migraci√≥n de un sistema de archivos local a un servicio de 
almacenamiento en la nube, como AWS S3, sea un proceso simple y de bajo riesgo que no 
requerir√° modificaciones en el c√≥digo de la API. Adem√°s, esta arquitectura mejora la 
mantenibilidad del c√≥digo y simplifica dr√°sticamente la creaci√≥n de pruebas unitarias. 
5. Despliegue y entorno de ejecuci√≥n (10%) 
‚Ä¢ Uso de Docker y Docker Compose: configuraci√≥n apropiada del entorno de despliegue, 
garantizando portabilidad y consistencia entre entornos. 
‚Ä¢ Configuraci√≥n de Nginx: implementaci√≥n adecuada de servidores de aplicaci√≥n y servidor proxy 
inverso para entornos de producci√≥n, asegurando rendimiento y estabilidad. 
6. Documentaci√≥n (10%) 
‚Ä¢ Modelo de datos: inclusi√≥n del modelo de datos de la aplicaci√≥n, representado mediante un 
diagrama Entidad-Relaci√≥n (ERD) o, en su defecto, a trav√©s de una especificaci√≥n detallada 
de las entidades, atributos y relaciones del sistema. 
‚Ä¢ Documentaci√≥n de la API: elaboraci√≥n y centralizaci√≥n de la documentaci√≥n de los 
endpoints, as√≠ como la ejecuci√≥n de pruebas correspondientes, mediante Postman. 
‚Ä¢ Diagrama de componentes: representaci√≥n de los principales elementos de la arquitectura, 
considerando backend, worker, broker y base de datos. 
‚Ä¢ Diagrama de flujo de procesos: descripci√≥n detallada de las etapas de carga, 
procesamiento y entrega de un archivo. 
‚Ä¢ Despliegue y documentaci√≥n: representaci√≥n de la infraestructura de ejecuci√≥n (m√°quinas 
virtuales, contenedores Docker y servicios activos) acompa√±ada de una gu√≠a clara, 
estructurada y reproducible que facilite la r√©plica del entorno en diferentes contextos. 
‚Ä¢ Reporte de an√°lisis de SonarQube: donde se evidencien los resultados del √∫ltimo an√°lisis 
sobre la rama principal del proyecto. Debe mostrar, al menos: 
o M√©tricas de bugs, vulnerabilidades y code smells. 
o Nivel de cobertura de pruebas unitarias (%). 
o Duplicaci√≥n de c√≥digo (%). 
o Estado del quality gate (aprobado/rechazado). 
7. Pruebas de carga (10%) 
‚Ä¢ Pruebas que eval√∫e el comportamiento y desempe√±o de la aplicaci√≥n bajo distintos niveles de 
concurrencia y volumen de solicitudes. Deber√° evaluar m√©tricas clave (latencia, throughput, 
utilizaci√≥n de recursos y tasa de errores), as√≠ como la interpretaci√≥n de resultados para identificar 
posibles cuellos de botella y proponer mejoras en la escalabilidad y estabilidad del sistema. 
Sugerencias para los equipos 
‚Ä¢ Planificaci√≥n: Antes de comenzar, es fundamental dise√±ar la arquitectura del sistema y planificar 
las tareas a realizar. 
‚Ä¢ Buenas pr√°cticas: Adoptar est√°ndares de codificaci√≥n y seguir patrones de dise√±o reconocidos. 
‚Ä¢ Pruebas continuas: Implementar pruebas unitarias y de integraci√≥n que contribuyan a la calidad del 
c√≥digo. 
‚Ä¢ Documentaci√≥n: Mantener una documentaci√≥n actualizada facilita el mantenimiento y la 
escalabilidad del proyecto. 
Formato de entrega 
1. Respecto a la documentaci√≥n, se recomienda: 
‚Ä¢ Organizar los contenidos siguiendo las pautas definidas en la secci√≥n anterior, asegurando la 
inclusi√≥n de todos los elementos esenciales. 
‚Ä¢ En el archivo principal README.md del repositorio, registre el nombre completo y el correo 
Uniandes de cada integrante del curso 
‚Ä¢ Alojar toda la documentaci√≥n en el repositorio de GitHub o GitLab, dentro de un directorio 
dedicado (/docs/Entrega_1), y referenciarla en el archivo README.md para facilitar su acceso. Esta 
misma estructura deber√° utilizarse en las entregas posteriores. 
‚Ä¢ En la ruta /sustentacion/Entrega_1, incluya el enlace a la video sustentaci√≥n correspondiente a la 
entrega, asegurando que sea accesible y funcione correctamente. 
‚Ä¢ Crear un directorio espec√≠fico (/collections) para las colecciones de Postman que contengan las 
solicitudes y pruebas correspondientes. Dichas colecciones deber√°n exportarse en formato JSON y 
almacenarse en el repositorio. La ejecuci√≥n automatizada de estas pruebas debe validarse 
mediante herramientas como el CLI newman, manteniendo esta estructura en las entregas 
posteriores. 
2. Incluir un conjunto de pruebas unitarias que validen el correcto funcionamiento de la aplicaci√≥n. 
3. Archivo .gitignore: Incluir un archivo .gitignore adecuado para excluir archivos y directorios que 
no deban ser versionados. 
4. Publicar una versi√≥n (release) del c√≥digo fuente en el repositorio del grupo en GitHub o GitLab, 
utilizando etiquetas (tags) que sigan el formato de versionado sem√°ntico (por ejemplo, v1.0.0) y 
proporcionando una descripci√≥n detallada de los cambios incluidos en dicha versi√≥n. 
Infraestructura requerida para el despliegue 
Para garantizar un despliegue simple y automatizado de la aplicaci√≥n, se establecen las siguientes 
directrices: 
‚Ä¢ Despliegue en contenedores: la aplicaci√≥n debe ejecutarse en contenedores Docker para 
garantizar portabilidad y consistencia. 
‚Ä¢ Sistema operativo base: Ubuntu seg√∫n los requerimientos del proyecto. 
‚Ä¢ Automatizaci√≥n: proveer un archivo docker-compose.yml que orqueste todos los servicios y permita 
el despliegue completo con docker compose up. 
Estas medidas buscan optimizar el proceso de despliegue, facilitando la gesti√≥n de la aplicaci√≥n. 
Notas: 
‚Ä¢ Esta fase no incluye el uso de proveedores de nube p√∫blica; dicha implementaci√≥n ser√° abordada 
en la siguiente etapa del proyecto. 
‚Ä¢ Utilice ambientes virtuales para su desarrollo local y valide que su configuraci√≥n de Docker funcione 
correctamente en uno de los sistemas operativos indicados; de ser necesario utilice un hipervisor 
gratuito u open source. Se recomienda Oracle VM VirtualBox. 
‚Ä¢ Los tutores del curso pueden solicitar una sustentaci√≥n s√≠ncrona y para esto se requiere la 
aplicaci√≥n en ejecuci√≥n. 
Recomendaciones y consideraciones 
El backend de la aplicaci√≥n web debe desarrollarse utilizando el lenguaje de programaci√≥n Python o Go. 
Para su ejecuci√≥n en un entorno local, la aplicaci√≥n debe contar al menos con los siguientes 
componentes: 
‚Ä¢ Sistema operativo: Ubuntu Server 24.04 LTS. 
‚Ä¢ Lenguaje del backend: Python o Golang. 
‚Ä¢ Framework: FastAPI para Python. Gin o Echo en el caso de Golang. 
‚Ä¢ Base de datos: MySQL o PostgreSQL. 
‚Ä¢ Gesti√≥n de tareas as√≠ncronas: Celery con Redis o RabbitMQ como message brokers en Python. 
Asynq o Machinery en el caso de Golang. 
‚Ä¢ Alternativa: Apache Kafka, lo que implica una arquitectura basada en el modelo publish/subscribe. 
‚Ä¢ Servidor web: Nginx, configurado como proxy inverso. 
Escenario de negocio y requisitos de la aplicaci√≥n 
Contexto 
La Asociaci√≥n Nacional de Baloncesto (ANB) es una organizaci√≥n reconocida por promover el 
desarrollo del talento emergente en el baloncesto a nivel regional y nacional. Con un enfoque en la 
inclusi√≥n y el impulso de nuevas generaciones de jugadores, la ANB busca identificar y proyectar a los 
futuros talentos del deporte a trav√©s de iniciativas innovadoras que aprovechan la tecnolog√≠a para 
democratizar el acceso a sus programas de selecci√≥n. 
En respuesta al creciente inter√©s de j√≥venes atletas que sue√±an con ser parte de los equipos profesionales, 
la ANB lanza la iniciativa ANB Rising Stars Showcase, un programa que se orienta a descubrir a los 
mejores jugadores aficionados de diferentes regiones del pa√≠s, brind√°ndoles la oportunidad de 
competir en un torneo de exhibici√≥n frente a los cazatalentos de la liga. Se trata, por tanto, de una 
competencia abierta que abarca varias ciudades en el territorio nacional. 
Como parte del proceso de preselecci√≥n, los jugadores aficionados enviar√°n videos cortos 
demostrando sus habilidades (entrenamientos, jugadas destacadas, lanzamientos, etc.). La ANB 
requiere el desarrollo de una plataforma web que sirva como centro de carga, almacenamiento y 
evaluaci√≥n de tales videos, permitiendo que tanto el p√∫blico general como un jurado 
especializado voten por los jugadores m√°s destacados. 
Al finalizar el proceso de votaci√≥n, los jugadores con el mayor n√∫mero de votos en cada ciudad ser√°n 
seleccionados para integrar los equipos que participar√°n en el torneo Rising Stars Showcase, con la 
posibilidad de ser reclutados por equipos profesionales. 
Requerimientos de la ANB 
‚Ä¢ Los jugadores podr√°n registrarse, crear un perfil y subir sus videos de prueba. 
‚Ä¢ La plataforma deber√° realizar procesamiento autom√°tico de los videos cargados: - 
Recorte de duraci√≥n a un m√°ximo de 30 segundos. - - - 
Ajuste de resoluci√≥n y formato de aspecto con el fin de mantener una calidad √≥ptima sin 
sobrecargar los servidores. 
Agregar una marca de agua de ANB para autenticar el contenido. 
Eliminar audio, puesto que no es relevante para la evaluaci√≥n de los jugadores. 
‚Ä¢ El p√∫blico podr√° ver los videos y votar. 
‚Ä¢ Se generar√° un ranking din√°mico, mostrando los jugadores m√°s votados. 
‚Ä¢ Las votaciones deben ser controladas para evitar fraudes o m√∫ltiples votos por usuario. 
El sistema debe habilitar la conversi√≥n de archivos de video de manera as√≠ncrona o mediante 
procesos batch, con el objetivo de optimizar la experiencia del usuario y evitar tiempos de espera 
prolongados. Una vez culminado el procesamiento, el estado del archivo debe actualizarse 
autom√°ticamente a "procesado", tal que los usuarios sean capaces de visualizar y utilizar sus videos 
sin interrupciones. 
Impacto esperado 
La ANB Rising Stars Showcase permitir√° democratizar el acceso al proceso de selecci√≥n de nuevos 
talentos en el baloncesto, reduciendo barreras geogr√°ficas y econ√≥micas. La plataforma tecnol√≥gica 
apoyar√° la misi√≥n de la ANB de fomentar el deporte e identificar j√≥venes promesas que puedan 
integrarse en el baloncesto profesional. 
Alcance del proyecto 
Registro de jugadores: Los jugadores aficionados pueden crear sus cuentas en la plataforma para 
participar en el proceso de selecci√≥n y hacer seguimiento a sus postulaciones. Se requiere la 
siguiente informaci√≥n: nombre, apellidos, ciudad, pa√≠s, correo electr√≥nico. 
Carga de videos: Los jugadores podr√°n subir videos cortos donde demuestren sus habilidades en el 
baloncesto, como lanzamientos, dribles, jugadas defensivas u otras destrezas. El video debe contar 
con una duraci√≥n m√≠nima de 20 segundos y m√°xima de 60 segundos, en calidad 1080p o superior. 
Procesamiento de videos: Los archivos de video subidos por los usuarios ser√°n procesados en 
segundo plano, evitando bloqueos en la API y mejorando la escalabilidad del sistema. 
‚Ä¢ La plataforma debe recortar cada video a una duraci√≥n m√°xima de 30 segundos. 
‚Ä¢ Ajustarse a una relaci√≥n de aspecto 16:9 y resoluci√≥n 720p. 
‚Ä¢ Incluir una cortinilla de apertura y cierre con el logotipo oficial de la Asociaci√≥n Nacional de 
Baloncesto (ANB). M√°ximo deben agregarle 5 segundos extra al video.  
Una vez completado el procesamiento, el estado del archivo se actualizar√° autom√°ticamente en la 
base de datos, reflejando su disponibilidad para visualizaci√≥n y evaluaci√≥n. 
Votaci√≥n: La plataforma permitir√° al p√∫blico en general votar por sus videos favoritos. 
Ranking: Un ranking din√°mico revelar√° los jugadores mejor posicionados, de acuerdo en el n√∫mero de 
votos recibidos. 
Descripci√≥n funcional de los servicios 
Gesti√≥n de usuarios (autenticaci√≥n y registro) 
1. Registro de Jugadores 
El sistema debe permitir que los jugadores aficionados se registren en la plataforma con el fin de 
participar en el proceso de selecci√≥n. El registro debe garantizar la validez de los datos, incluyendo la 
verificaci√≥n de un correo electr√≥nico √∫nico. Asimismo, se requiere la implementaci√≥n de mecanismos 
de seguridad para la gesti√≥n de contrase√±as, asegurando su cifrado y almacenamiento mediante 
hashing. 
{ 
} 
"first_name": "John", 
"last_name": "Doe", 
"email": "john@example.com", 
"password1": "StrongPass123", 
"password2": "StrongPass123", 
"city": "Bogot√°", 
"country": "Colombia" 
En la solicitud de registro se solicitan dos campos de contrase√±a (password1 y password2) 
√∫nicamente con el prop√≥sito de validar que el usuario introduzca y confirme una misma 
contrase√±a, minimizando errores de tipeo y asegurando que el valor definido sea recordado. 
No obstante, en el sistema solo se almacena un √∫nico valor de contrase√±a (despu√©s de 
aplicar el correspondiente proceso de hashing y cifrado), descart√°ndose el campo 
redundante tras la validaci√≥n inicial. 
C√≥digos de respuesta: 
C√≥digo 
Descripci√≥n 
Usuario creado exitosamente. 
201 
400 
Error de validaci√≥n (email duplicado, contrase√±as no 
coinciden). 
2. Inicio de Sesi√≥n 
El sistema debe permitir que los usuarios se autentiquen en la plataforma mediante el 
suministro de su correo electr√≥nico y contrase√±a. Como respuesta, se debe generar y 
devolver un token JWT que deber√° ser utilizado en todas las solicitudes autenticadas 
posteriores. Asimismo, es obligatorio implementar un control de sesiones basado en 
tokens JWT, contemplando mecanismos de expiraci√≥n (es suficiente con establecer 
tiempos de expiraci√≥n cortos para los tokens, es una soluci√≥n simple). 
Ejemplo de request 
{ 
} 
" email ": " john@example.com ",  
"password": "StrongPass123" 
Ejemplo de respuesta exitosa 
{ 
"access_token": "eyJ0eXAiOiJKV1QiLCJhbGci...", "token_type": 
"Bearer", 
"expires_in": 3600 
} 
C√≥digos de respuesta 
C√≥digo 
200 
Descripci√≥n 
Autenticaci√≥n exitosa, retorna token. 
401 
Credenciales inv√°lidas. 
Gesti√≥n de videos (carga, procesamiento y acceso) 
1. Carga de video 
El sistema debe permitir que los jugadores suban un video. Dicho video se almacenar√° en el sistema 
de archivos y, de manera autom√°tica, se registrar√° una tarea de procesamiento as√≠ncrono encargada 
de recortar el contenido, ajustarlo al formato 16:9 y a√±adir los logos institucionales de la ANB. 
Manejo de estados: el archivo deber√° contar con un flujo de estados claramente definido. 
Inicialmente se marcar√° como ‚Äúuploaded‚Äù y, una vez completado el procesamiento en segundo plano, 
pasar√° al estado ‚Äúprocessed‚Äù. 
En lugar de esperar a que un proceso externo consulte la base de datos, el endpoint debe 
activamente encolar una tarea en el broker de mensajer√≠a (Asynq o Machinery/Kafka). El API no 
espera a que el video se procese. Una vez que la tarea ha sido encolada, responde inmediatamente al 
cliente. 
Este ajuste asegura que el sistema sea m√°s eficiente y escalable, ya que las tareas se distribuyen 
activamente a los workers en el momento de su creaci√≥n, en lugar de depender de un proceso de 
sondeo (polling) que consume recursos innecesariamente. 
Par√°metros (form-data) 
Nombre 
Tipo 
Requerido 
Descripci√≥n 
video_file 
archivo 
S√≠ 
Archivo de video en formato MP4, 
m√°ximo 100MB. 
title 
string 
S√≠ 
T√≠tulo descriptivo del video. 
Ejemplo de respuesta exitosa 
{ 
"message": "Video subido correctamente. Procesamiento en curso.",  
"task_id": "123456" 
} 
C√≥digos de Respuesta 
C√≥digo 
Descripci√≥n 
201 
Video subido exitosamente, tarea creada. 
Error en el archivo (tipo o tama√±o inv√°lido). 
400 
401 
Falta de autenticaci√≥n. 
2. Consultar mis videos 
Permite al jugador consultar el listado de sus videos subidos, junto con el estado de 
procesamiento y las URLs de acceso (si el procesamiento est√° completo). 
Ejemplo de respuesta 
[ 
] 
{ 
}, 
{ 
} 
"video_id": "123456", 
"title": "Mi mejor tiro de 3",  
"status": "processed ", 
"uploaded_at": "2025-03-10T14:30:00Z", 
"processed_at": "2025-03-10T14:35:00Z", 
"processed_url": "https://anb.com/videos/processed/123456.mp4" 
"video_id": "654321", 
"title": "Habilidades de dribleo",  
"status": "uploaded ", 
"uploaded_at": "2025-03-11T10:15:00Z" 
C√≥digos de respuesta 
C√≥digo 
Descripci√≥n 
200 
Lista de videos obtenida. 
Falta de autenticaci√≥n. 
401 
3. Consultar detalle de un video espec√≠fico 
Permite recuperar el detalle de una tarea de video espec√≠fica, incluyendo la URL de descarga 
del video procesado, si est√° disponible. 
Ejemplo de respuesta exitosa 
{ 
"video_id": "a1b2c3d4", 
"title": "Tiros de tres en movimiento",  
"status": "processed ", 
"uploaded_at": "2025-03-15T14:22:00Z", 
"processed_at": "2025-03-15T15:10:00Z",  
"original_url": "https://anb.com/uploads/a1b2c3d4.mp4", 
"processed_url": "https://anb.com/processed/a1b2c3d4.mp4",  
"votes": 125 
} 
C√≥digos de respuesta 
C√≥digo 
200 OK 
Descripci√≥n 
Consulta exitosa. Se devuelve el detalle del video. 
401 Unauthorized 
El usuario no est√° autenticado o el token JWT es 
inv√°lido o expirado. 
403 Forbidden 
El usuario autenticado no tiene permisos para acceder 
a este video (no es el propietario). 
404 Not Found 
El video con el video_id especificado no existe o no 
pertenece al usuario. 
4. Eliminar video subido 
Permite al jugador eliminar uno de sus videos (tanto el original como el procesado), solo si no ha sido 
publicado para votaci√≥n o a√∫n no ha sido procesado. 
Ejemplo de respuesta exitosa 
{ 
"message": "El video ha sido eliminado exitosamente.",  
"video_id": "a1b2c3d4" 
} 
C√≥digos de respuesta 
C√≥digo 
Descripci√≥n 
200 OK 
El video ha sido eliminado correctamente. Se confirman 
los cambios en la base de datos y almacenamiento. 
400 Bad Request 
El video no puede ser eliminado porque no cumple las condiciones 
(por ejemplo, ya est√° habilitado para 
votaci√≥n). 
401 Unauthorized 
El usuario no est√° autenticado o el token JWT es inv√°lido 
o expirado. 
403 Forbidden 
El usuario autenticado no tiene permisos para eliminar 
este video (no es el propietario). 
404 Not Found 
El video con el video_id especificado no existe o no 
pertenece al usuario autenticado. 
Sistema de votaci√≥n p√∫blica 
1. Listar videos disponibles para votar 
Lista todos los videos p√∫blicos habilitados para votaci√≥n. 
2. Emitir voto por un video 
Permite a un usuario registrado emitir un voto por un video espec√≠fico. Un usuario solo puede 
votar una vez por video. Un usuario puede votar por varios videos, pero solo puede votar una vez 
por video. 
Ejemplo de respuesta 
{ 
"message": "Voto registrado exitosamente." 
} 
C√≥digos de respuesta 
C√≥digo 
Descripci√≥n 
Voto exitoso. 
200 
400 
Ya has votado por este video. 
Video no encontrado. 
404 
401 
Falta de autenticaci√≥n. 
Ranking de jugadores 
1. Consultar tabla de clasificaci√≥n 
Provee un ranking actualizado, en el que los competidores son organizados respecto al 
n√∫mero de votos obtenidos. Puede incluir filtros para mostrar diferentes rangos de 
posiciones, por ejemplo, filtrar por ciudad. 
Si el n√∫mero de videos y votos es alto, calcular este ranking en tiempo real con cada 
llamada a la API puede generar una carga excesiva en la base de datos y aumentar la 
latencia. 
Recomendaci√≥n: Implementar una estrategia de caching (ej. en Redis) para los resultados 
del ranking, con un tiempo de vida (TTL) corto (p. ej., 1 a 5 minutos). Alternativamente, se 
puede utilizar una vista materializada en PostgreSQL que se actualice peri√≥dicamente. 
Ejemplo de respuesta 
[ 
{ 
}, 
{ 
} 
] 
"position": 1, 
"username": "superplayer", "city": "Bogot√°", 
"votes": 1530 
"position": 2, "username": "nextstar", "city": "Bogot√°", "votes": 1495 
C√≥digos de respuesta 
C√≥digo 
Descripci√≥n 
200 
400 
Lista de rankings obtenida. 
Par√°metro inv√°lido en la consulta. 
 
 
Especificaci√≥n del API REST 
En este proyecto deber√° crear los siguientes endpoints para su API REST. Esta definici√≥n deber√° ser 
respetada a lo largo del desarrollo del proyecto. 
 
 Endpoint M√©todo Descripci√≥n Autenticaci√≥n Notas 
1 /api/auth/signup POST Registro de 
nuevos 
jugadores en la 
plataforma. 
No Valida email 
√∫nico y 
confirmaci√≥n de 
contrase√±a. 
2 /api/auth/login POST Autenticaci√≥n 
de usuarios y 
generaci√≥n de 
token JWT. 
No Devuelve token 
JWT v√°lido para 
autenticaci√≥n 
posterior. 
3 /api/videos/upload POST Permite a un 
jugador subir 
un  video  de 
habilidades. 
S√≠ (JWT) Inicia proceso 
as√≠ncrono de 
procesamiento 
del video. 
4 /api/videos GET Lista todos los 
videos subidos 
por el usuario 
autenticado. 
S√≠ (JWT) Muestra estado: 
"uploaded" o 
"processed". 
5 /api/videos/{video_id} GET Obtiene el 
detalle de un 
video 
espec√≠fico del 
usuario. 
S√≠ (JWT) Incluye URLs 
para 
ver/descargar 
los videos (si 
est√° listo). 
6 /api/videos/{video_id} DELETE Elimina un 
video propio, si 
a√∫n es 
permitido. 
S√≠ (JWT) Solo si el video 
no ha sido 
publicado para 
votaci√≥n. 
7 /api/public/videos GET Lista los videos 
p√∫blicos 
disponibles 
para votaci√≥n. 
Opcional  
8 /api/public/videos/{video_id}/ vote POST Emite un voto 
por  un  video 
p√∫blico. 
S√≠ (JWT) Limita un voto 
por usuario por 
video. 
9 /api/public/rankings GET Muestra el 
ranking actual 
de los 
jugadores por 
votos 
acumulados. 
No Soporta 
paginaci√≥n y 
filtros. 
Nota: En los endpoints que requieran autenticaci√≥n, como consultar mis videos, el email no 
debe ser enviado por el cliente, ya sea en el cuerpo de la solicitud o como par√°metro en la 
URL. 
La identidad del usuario autenticado debe obtenerse exclusivamente a partir del token JWT incluido 
en el encabezado Authorization. El backend es responsable de validar dicho token y asociar la 
operaci√≥n al usuario correspondiente, garantizando as√≠ la seguridad y la integridad de la 
informaci√≥n gestionada por la aplicaci√≥n. 
Para el procesamiento de conversi√≥n de archivos, la aplicaci√≥n debe ejecutar un proceso 
as√≠ncrono que garantice una experiencia de usuario fluida. 
Con el fin de evitar que el usuario permanezca esperando mientras sus videos son 
procesados para cumplir con las caracter√≠sticas t√©cnicas definidas, la edici√≥n de los archivos 
se realiza mediante tareas en segundo plano, gestionadas de forma as√≠ncrona o en procesos 
batch. Una vez finalizado el procesamiento, el estado del archivo se actualiza a "processed" en 
la aplicaci√≥n. 
Por lo tanto, la aplicaci√≥n deber√° contar con un proceso as√≠ncrono y distribuido, que se ejecute 
en segundo plano. Este proceso se encargar√° de consultar de manera peri√≥dica la base de datos 
para identificar archivos en estado "uploaded", y proceder a realizar las siguientes acciones: 
‚Ä¢ Editar el video para ajustarlo a las especificaciones establecidas, como la duraci√≥n 
m√°xima, la relaci√≥n de aspecto y la inclusi√≥n de los elementos gr√°ficos requeridos (por 
ejemplo, el logo de la ANB). 
‚Ä¢ Guardar el video procesado en el sistema de archivos, conservando tambi√©n el archivo 
original. 
‚Ä¢ Actualizar el estado del video a "processed" en la base de datos. 
Estas funcionalidades deber√°n ofrecerse dentro de una √∫nica aplicaci√≥n web, ejecut√°ndose 
de manera as√≠ncrona mediante un sistema de tareas. 
Por otro lado, aunque se desarrollar√° una interfaz gr√°fica de usuario, la validaci√≥n de los servicios 
deber√° realizarse mediante un conjunto de escenarios de prueba automatizados utilizando 
Postman. Esta herramienta permitir√° documentar y probar los endpoints del API REST. 
El equipo de trabajo deber√° crear un workspace en Postman, en el cual colaborar√°n para 
consolidar la colecci√≥n de endpoints de la aplicaci√≥n. 
Dicha colecci√≥n deber√° incluir: 
‚Ä¢ Par√°metros requeridos para cada solicitud. 
‚Ä¢ Escenarios de prueba de ejemplo. 
‚Ä¢ Documentaci√≥n de los mensajes de error y excepciones. 
Ilustraci√≥n 1. Ejemplo, documentaci√≥n de un API REST en POSTMAN 
Para facilitar la automatizaci√≥n de la validaci√≥n de los endpoints de la API, se debe crear un 
directorio espec√≠fico en el repositorio del proyecto. Las colecciones de Postman, que 
contienen las solicitudes y las pruebas correspondientes, deben exportarse en formato JSON 
y almacenarse en la ruta /collections. 
Se recomienda validar la ejecuci√≥n automatizada de dichas pruebas utilizando herramientas 
como el CLI newman. Esto asegurar√° la correcta validaci√≥n de los endpoints de manera 
reproducible y consistente. 
Esta estructura deber√° mantenerse para las entregas posteriores, estandarizando el manejo 
de las pruebas y la documentaci√≥n de la API REST en el proyecto. 
Adem√°s de la colecci√≥n de pruebas, es necesario crear un archivo de entorno llamado 
postman_environment.json. Este archivo debe incluir todas las variables necesarias para la 
ejecuci√≥n automatizada de las pruebas, como, por ejemplo: 
base_url 
URL base de la API desplegada 
(ej. http://localhost:8000/api). 
deploy_url 
URL base de la API desplegada 
(ej. http://ip_de_su_proyecto:8000/api). 
Nota: Para la primera entrega no se har√° uso de la variable deploy_url. Este variable debe existir 
para que pueda ser validado su despliegue en entregas posteriores. 
Pruebas unitarias 
Como parte fundamental del desarrollo del proyecto, cada equipo debe implementar y 
ejecutar pruebas unitarias que validen el correcto funcionamiento de los componentes 
principales de la aplicaci√≥n. Las pruebas deben cubrir, al menos, los casos de uso m√°s 
relevantes y los servicios expuestos a trav√©s de la API REST. 
Estas pruebas deben garantizar la calidad del c√≥digo, facilitar la detecci√≥n temprana de errores y 
permitir validar autom√°ticamente el comportamiento de la aplicaci√≥n antes de su despliegue. 
Pipeline CI/CD 
La Integraci√≥n Continua (CI) en GitHub constituye una pr√°ctica esencial que permite automatizar 
la construcci√≥n, validaci√≥n y aseguramiento de la calidad del software. A trav√©s de GitHub 
Actions o Gilab-CI, cada cambio enviado al repositorio (por ejemplo, mediante pull requests o 
push a una rama principal) activa un pipeline que ejecuta de manera sistem√°tica las validaciones 
definidas. 
En este caso, el pipeline se limitar√° a dos etapas fundamentales: 
‚Ä¢ Ejecuci√≥n de pruebas unitarias: se valida la funcionalidad del c√≥digo asegurando que cada 
componente cumpla con el comportamiento esperado. 
‚Ä¢ Construcci√≥n autom√°tica de la aplicaci√≥n: se genera el artefacto de la aplicaci√≥n en un 
entorno reproducible, garantizando consistencia en futuros despliegues. 
Adicionalmente, el pipeline incorpora la validaci√≥n de la calidad del c√≥digo con SonarQube, lo 
que permite detectar vulnerabilidades, errores, code smells y problemas de mantenibilidad antes 
de integrar los cambios en la rama principal. 
An√°lisis de capacidad 
Lea el documento anexo ‚ÄúEntrega 1 - An√°lisis de Capacidad‚Äù para conocer toda la 
especificaci√≥n del an√°lisis de capacidad que debe realizar a la aplicaci√≥n. 
El plan de an√°lisis de capacidad debe ser organizado y entregado dentro del repositorio del 
proyecto. Para ello, se debe crear una carpeta espec√≠fica llamada /capacity-planning, donde 
se almacenar√° el documento correspondiente. 
El plan debe estar documentado en un archivo llamado plan_de_pruebas.md, el cual debe incluir 
el plan an√°lisis detallado de capacidad de la aplicaci√≥n, los escenarios de carga planteados, 
las m√©tricas seleccionadas, los resultados esperados y las recomendaciones para escalar la 
soluci√≥n. Esta estructura debe mantenerse de forma consistente en las futuras entregas del 
proyecto. 



# Arquitectura de Software - ANB Rising Stars Showcase

## 1. Recolecci√≥n de Requisitos

**Funcionales:**
- Gesti√≥n de usuarios: registro, autenticaci√≥n, perfiles.
- Carga de videos por jugadores.
- Procesamiento as√≠ncrono de videos: recorte, ajuste de resoluci√≥n/aspecto, marca de agua, eliminaci√≥n de audio, cortinilla.
- Votaci√≥n p√∫blica y ranking de jugadores.
- Consulta y descarga de videos procesados.
- Eliminaci√≥n de videos bajo condiciones.
- Gesti√≥n del ciclo de vida de los archivos.
- Exposici√≥n de endpoints REST documentados con OpenAPI.

**No funcionales:**
- Escalabilidad (procesamiento y concurrencia).
- Seguridad (autenticaci√≥n, autorizaci√≥n, gesti√≥n de contrase√±as, JWT).
- Disponibilidad y resiliencia.
- Portabilidad (contenedores Docker).
- Facilidad de despliegue (docker-compose, Nginx proxy).
- Documentaci√≥n y pruebas automatizadas.

---

## 2. Restricciones

- Backend en Python (FastAPI) o Go (Gin/Echo). Se opta por **Python + FastAPI** por robustez y ecosistema de procesamiento de videos.
- Base de datos relacional: **PostgreSQL** (alternativa: MySQL).
- Broker de mensajes: **RabbitMQ** (alternativa: Redis, Kafka).
- Procesamiento as√≠ncrono: **Celery** (alternativa: Kafka).
- Almacenamiento inicial: sistema de archivos local (abstra√≠do para futura migraci√≥n a S3).
- Despliegue en Docker (Ubuntu base).
- Nginx como proxy inverso.
- Pruebas con Postman y Newman.
- SonarQube para an√°lisis de calidad.
- No se permite a√∫n uso de nube p√∫blica.
- Autenticaci√≥n y autorizaci√≥n v√≠a JWT.

---

## 3. Estilo y Principios Arquitect√≥nicos

- **Microservicio modularizado** (aunque todo en una √∫nica app web para entrega 1, con separaci√≥n clara de responsabilidades).
- **Event-driven** para procesamiento as√≠ncrono (tareas encoladas y procesadas por worker).
- **API-first**: contratos claros, documentados y validados.
- **Abstracci√≥n de infraestructura** (almacenamiento, procesamiento desacoplado (Para futura migraci√≥n a S3)).
- **Defensa en profundidad** para seguridad.

---

## 4. Modelado de la Soluci√≥n (C4, alto nivel)

### Diagrama de Contexto (C4 - Nivel 1)
- Usuarios: Jugadores, Jurado/P√∫blico, Admins.
- Sistema: Plataforma ANB Rising Stars Showcase.
- Integraciones: Email (para registro), almacenamiento de archivos, sistema de procesamiento de videos.

```mermaid
graph TB
    subgraph "ANB Rising Stars Showcase"
        A[Plataforma ANB Rising Stars]
    end
    
    subgraph "Personas"
        B[Jugadores Aficionados]
        C[P√∫blico General]
        D[Jurado Especializado]
        E[Administradores ANB]
    end
    
    subgraph "Sistemas Externos"
        G[Local Storage / Servicio de Almacenamiento Cloud]
        H[Servicio de Procesamiento Video]
        I[CDN para Distribuci√≥n]
    end
    
    B -- "Registra, sube videos,<br>consulta estado" --> A
    C -- "Ve videos, vota,<br>consulta ranking" --> A
    D -- "Eval√∫a, vota,<br>selecciona talentos" --> A
    E -- "Administra, monitorea,<br>genera reportes" --> A
    
    A -- "Almacena archivos,<br>backups" --> G
    A -- "Procesamiento avanzado<br>de video" --> H
    A -- "Distribuci√≥n global<br>de videos" --> I```


### Diagrama de Contenedores (C4 - Nivel 2)

**Componentes principales:**

- **API Gateway (Nginx):** Proxy inverso, redirecciona tr√°fico HTTP/HTTPS.
- **Backend API (FastAPI):** Expone endpoints REST, gestiona autenticaci√≥n, usuarios, videos, votos, rankings.
- **Task Worker (Celery):** Procesa videos en segundo plano, conectado al broker de mensajes.
- **Broker de Mensajes (RabbitMQ):** Encola tareas as√≠ncronas.
- **Base de Datos (PostgreSQL):** Persiste usuarios, videos, votos.
- **Almacenamiento de Archivos:** Sistema de archivos local con capa de abstracci√≥n.
- **Cache (Redis):** Almacena resultados de ranking y sesiones temporales.
- **SonarQube:** An√°lisis de calidad del c√≥digo.
- **Postman/Newman:** Pruebas de API automatizadas.


```mermaid
graph TB
    subgraph "ANB Platform - Container Architecture"
        subgraph "Web Layer"
            A[NGINX<br>Reverse Proxy<br>Load Balancer]
        end
        
        subgraph "Application Layer"
            B[FastAPI<br>REST API Server<br>Python 3.11]
            C[Celery Worker<br>Video Processing<br>Python 3.11]
        end
        
        subgraph "Data Layer"
            D[PostgreSQL<br>Main Database<br>v13]
            E[Redis<br>Cache<br>v7]
        end
        
        subgraph "Message Broker"
            F[RabbitMQ<br>Message Broker<br>v3.12]
        end
        
        subgraph "Storage Layer"
            G[Local File System<br>Video Storage<br>Ext4 / AWS S3]
        end
        
    end
    
    J[Web Browser<br>Usuario Final] --> A
    
    A --> B
    B --> D
    B --> E
    B --> F
    B --> G
    
    F --> C
    C --> D
    C --> G
    C --> E
    ```


### Diagrama de Componentes (C4 - Nivel 3)

- **Auth Module:** Registro, login, JWT, gesti√≥n de contrase√±as.
- **Video Module:** Upload, consulta, detalle, eliminaci√≥n.
- **Async Task Manager:** Orquestaci√≥n de procesamiento de video.
- **Voting Module:** Lista de videos p√∫blicos, votaci√≥n, control antifraude.
- **Ranking Module:** Generaci√≥n din√°mica y cache de rankings.
- **Storage Adapter:** Abstracci√≥n para sistema de archivos, preparada para S3.

```mermaid
graph TB
    subgraph "FastAPI Application"
        subgraph "API Gateway Layer"
            A[Route Dispatcher<br/>/api/*]
        end
        
        subgraph "Business Components"
            B[Auth Module]
            C[Video Module]
            D[Voting Module]
            E[Ranking Module]
        end
        
        subgraph "Infrastructure Components"
            F[Async Task Manager]
            G[Storage Adapter]
        end
    end
    
    subgraph "External Systems"
        H[PostgreSQL<br/>Main Database]
        I[Redis<br/>Cache]
        J[RabbitMQ<br/>Message Broker]
        K[File System<br/>Video Storage]
        L[Future: AWS S3]
    end
    
    %% Internal connections
    A --> B
    A --> C
    A --> D
    A --> E
    
    C --> F
    C --> G
    
    %% External connections
    B --> H
    C --> H
    D --> H
    E --> H
    
    D --> I
    E --> I
    
    F --> J
    F --> H
    F --> K
    
    G --> K
    G -.-> L

```

---

## 5. Selecci√≥n de Tecnolog√≠as

| Componente               | Tecnolog√≠a          | Justificaci√≥n                                      |
|--------------------------|--------------------|----------------------------------------------------|
| API REST                 | FastAPI (Python)   | Alto rendimiento, OpenAPI, f√°cil de testear        |
| Base de datos            | PostgreSQL         | Escalable, soporte JSON, vistas materializadas     |
| Broker de mensajes       | RabbitMQ           | Fiable, soporta DLQ y reintentos                   |
| Tareas as√≠ncronas        | Celery             | Integraci√≥n nativa con Python, soporte para RabbitMQ|
| Almacenamiento archivos  | Sistema de archivos (abstracci√≥n S3) | Migraci√≥n futura sencilla                    |
| Proxy reverso            | Nginx              | Estabilidad y rendimiento                          |
| Cache                    | Redis              | TTL rankings, sesiones                             |
| CI/CD                    | GitHub Actions     | Automatizaci√≥n pruebas y SonarQube                 |
| An√°lisis calidad         | SonarQube          | Control de bugs/vulnerabilidades                   |
| Pruebas de API           | Postman/Newman     | Documentaci√≥n y automatizaci√≥n                     |
| Contenedores             | Docker/Docker Compose | Portabilidad y consistencia                     |

---

## 6. Patrones y Pr√°cticas

- **Repository Pattern:** Para acceso a la base de datos.
- **Adapter Pattern:** Para almacenamiento de archivos.
- **Service Layer:** Negocio desacoplado de controladores.
- **JWT:** Autenticaci√≥n y autorizaci√≥n.
- **Retry/Backoff:** Para tareas fallidas en Celery.
- **Dead Letter Queue:** En RabbitMQ para tareas no procesadas.
- **Logging estructurado:** Para trazabilidad.
- **Validaci√≥n exhaustiva:** Pydantic para entrada de datos.
- **Testing:** Pytest y coverage para unitarias.

---

## 7. Escalabilidad y Seguridad

- **Escalabilidad:** Worker de procesamiento horizontalmente escalable, API stateless, cach√© para rankings.
- **Seguridad:** JWT, hash de contrase√±as (bcrypt), validaci√≥n de inputs, control de acceso en endpoints.
- **Resiliencia:** Uso de DLQ en RabbitMQ, reintentos autom√°ticos, almacenamiento desacoplado.

---

## 8. Documentaci√≥n

- **Diagramas:** Incluidos en `/docs/Entrega_1/` (C4, ERD, despliegue).
- **OpenAPI:** Documentaci√≥n generada autom√°ticamente por FastAPI.
- **Pruebas Postman:** Colecciones en `/collections/`.
- **Gu√≠a de despliegue:** Paso a paso reproducible en README.

---

## 9. Validaci√≥n y Mejora

- **Revisi√≥n por equipo y tutor.**
- **Pruebas de carga y stress.**
- **Monitoreo con logs y m√©tricas.**
- **Iteraci√≥n por feedback.**

---

## 10. Despliegue (Docker Compose)

- **Servicios:** api, worker, rabbitmq, postgres, redis, nginx, sonar.
- **Ambientes:** desarrollo y productivo reproducibles.
- **Scripts de inicializaci√≥n:** para base de datos y migraciones.
- **Montaje de vol√∫menes:** para persistencia de archivos y bases de datos.



 

---

## 11. Diagrama de Despliegue

```mermaid
graph TB
    A[üë§ Usuario] <--> B[üîÑ Nginx<br/>Reverse Proxy<br/>Docker]
    B --> C[‚ö° API FastAPI<br/>Python Application<br/>Docker]
    C --> D[‚öôÔ∏è Celery Worker<br/>Video Processing<br/>Docker]
    
    C --> E[üêá RabbitMQ<br/>Message Broker<br/>Docker]
    C --> F[üêò PostgreSQL<br/>Main Database<br/>Docker]
    C --> G[üî¥ Redis<br/>Cache<br/>Docker]
    
    D --> E
    D --> F
    D --> G
    
    C --> H[üíΩ Volumen Archivos<br/>Locales Host<br/> AWS S3]
    D --> H
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#e8f5e8
    style D fill:#f3e5f5
    style E fill:#ffebee
    style F fill:#e0f2f1
    style G fill:#fff8e1
    style H fill:#fce4ec
```
---


## 12. Diagrama Entidad-Relaci√≥n (ERD) 


```mermaid
erDiagram
    USERS {
        string id PK "UUID"
        string email UK "NOT NULL"
        string first_name "NOT NULL"
        string last_name "NOT NULL"
        string city
        string country
        string password_hash "NOT NULL"
        datetime created_at "NOT NULL"
        datetime updated_at "NOT NULL"
    }

    VIDEOS {
        string id PK "UUID"
        string user_id FK "NOT NULL"
        string title "NOT NULL"
        string original_filename "NOT NULL"
        string status "NOT NULL"
        string original_url "NOT NULL"
        string processed_url
        integer duration_seconds
        integer votes_count "DEFAULT 0"
        datetime uploaded_at "NOT NULL"
        datetime processed_at
        datetime created_at "NOT NULL"
    }

    VOTES {
        string id PK "UUID"
        string user_id FK "NOT NULL"
        string video_id FK "NOT NULL"
        datetime voted_at "NOT NULL"
    }

    PROCESSING_TASKS {
        string id PK "UUID"
        string video_id FK "NOT NULL"
        string task_id "NOT NULL"
        string status "NOT NULL"
        json task_metadata
        datetime created_at "NOT NULL"
        datetime updated_at "NOT NULL"
    }

    USERS ||--o{ VIDEOS : "creates"
    USERS ||--o{ VOTES : "makes"
    VIDEOS ||--o{ VOTES : "receives"
    VIDEOS ||--o{ PROCESSING_TASKS : "has"```

## 13. Decisiones arquitect√≥nicas clave (ADR)

- **ADR-001:** Uso de FastAPI por velocidad y OpenAPI.
- **ADR-002:** Procesamiento de videos as√≠ncrono con Celery+RabbitMQ.
- **ADR-003:** Almacenamiento desacoplado para migraci√≥n futura a S3.
- **ADR-004:** JWT para autenticaci√≥n.
- **ADR-005:** Cach√© de ranking con Redis.
- **ADR-006:** Nginx como proxy inverso.



```
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/                 # Routers/endpoints organizados por dominio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ videos.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ votes.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rankings.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ core/                # Configuraci√≥n, dependencias, seguridad, utils
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deps.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Modelos ORM (SQLAlchemy/Pydantic)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ video.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vote.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ processing_task.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ schemas/             # Esquemas de validaci√≥n (Pydantic)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ video.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vote.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ranking.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/            # L√≥gica de negocio modularizada
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ video_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vote_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ranking_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage_service.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ storage/             # Adaptadores para almacenamiento de archivos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ local.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ s3.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ celery_worker/       # Worker y tasks as√≠ncronas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tasks.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ main.py              # Entrada principal de FastAPI
‚îÇ   ‚îî‚îÄ‚îÄ celery_app.py        # Configuraci√≥n de Celery
‚îÇ
‚îú‚îÄ‚îÄ tests/                   # Pruebas unitarias y de integraci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py
‚îÇ   ‚îú‚îÄ‚îÄ test_users.py
‚îÇ   ‚îú‚îÄ‚îÄ test_videos.py
‚îÇ   ‚îú‚îÄ‚îÄ test_votes.py
‚îÇ   ‚îú‚îÄ‚îÄ test_rankings.py
‚îÇ   ‚îî‚îÄ‚îÄ test_processing.py
‚îÇ
‚îú‚îÄ‚îÄ migrations/              # Migraciones de base de datos (alembic)
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ requirements-dev.txt
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ pyproject.toml           # Opcional, para herramientas modernas
‚îú‚îÄ‚îÄ .env.example
‚îÇ
‚îú‚îÄ‚îÄ docker/                  # Configuraci√≥n de servicios Docker externos
‚îÇ   ‚îú‚îÄ‚îÄ nginx/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ nginx.conf
‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ Entrega_1/
‚îÇ       ‚îú‚îÄ‚îÄ arquitectura-software.md
‚îÇ       ‚îú‚îÄ‚îÄ estructura-proyecto.md
‚îÇ       ‚îú‚îÄ‚îÄ diagramas/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ c4-contexto.png
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ c4-contenedores.png
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ c4-componentes.png
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ erd.png
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ despliegue.png
‚îÇ       ‚îú‚îÄ‚îÄ decisiones-adr.md
‚îÇ       ‚îú‚îÄ‚îÄ guia-despliegue.md
‚îÇ       ‚îî‚îÄ‚îÄ modelo-datos.md
‚îÇ
‚îú‚îÄ‚îÄ collections/             # Colecciones y entornos de Postman
‚îÇ   ‚îú‚îÄ‚îÄ postman_collection.json
‚îÇ   ‚îî‚îÄ‚îÄ postman_environment.json
‚îÇ
‚îú‚îÄ‚îÄ capacity-planning/
‚îÇ   ‚îî‚îÄ‚îÄ plan_de_pruebas.md
‚îÇ
‚îú‚îÄ‚îÄ sustentacion/
‚îÇ   ‚îî‚îÄ‚îÄ Entrega_1/
‚îÇ       ‚îî‚îÄ‚îÄ video_sustentacion.md (o link)
‚îÇ
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ LICENSE
```